<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì²´ìŠ¤ íƒ€ì›Œ ë””íœìŠ¤</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a1a1a;
            color: #e5e5e5;
            overflow: hidden; /* ìŠ¤í¬ë¡¤ ë°©ì§€ */
        }

        /* ìº”ë²„ìŠ¤ ìŠ¤íƒ€ì¼ */
        #gameCanvas {
            background-color: #2d2d2d;
            border: 2px solid #4a4a4a;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
        }

        /* ì²´ìŠ¤íŒ ëŠë‚Œì˜ ê·¸ë¦¬ë“œ ë°°ê²½ (JSë¡œ ê·¸ë¦´ ì˜ˆì •ì´ì§€ë§Œ CSS ë³´ì¡°) */
        .panel {
            background-color: #262626;
            border-left: 1px solid #404040;
        }

        .btn {
            transition: all 0.2s;
        }
        .btn:active {
            transform: scale(0.95);
        }
        
        /* ìŠ¤í¬ë¡¤ë°” ì»¤ìŠ¤í…€ */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1a1a1a; 
        }
        ::-webkit-scrollbar-thumb {
            background: #555; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #777; 
        }

        .tower-card {
            transition: transform 0.2s, border-color 0.2s;
        }
        .tower-card:hover {
            transform: translateY(-2px);
            border-color: #60a5fa;
        }
        .tower-card.selected {
            border-color: #3b82f6;
            background-color: #1e3a8a;
        }
    </style>
</head>
<body class="flex h-screen w-screen">

    <!-- ì™¼ìª½: ê²Œì„ ìº”ë²„ìŠ¤ -->
    <div class="flex-1 flex items-center justify-center relative bg-stone-900">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- ê²Œì„ ì˜¤ë²„ / ìŠ¹ë¦¬ ëª¨ë‹¬ -->
        <div id="modalOverlay" class="absolute inset-0 bg-black/80 hidden flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg text-center border border-gray-600 shadow-2xl">
                <h2 id="modalTitle" class="text-4xl font-bold mb-4 text-white">GAME OVER</h2>
                <p id="modalMessage" class="text-gray-300 mb-6 text-lg">ì›¨ì´ë¸Œ 10ì—ì„œ íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.</p>
                <button onclick="location.reload()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg transform transition hover:scale-105">
                    ë‹¤ì‹œ ì‹œì‘
                </button>
            </div>
        </div>

        <!-- ì•Œë¦¼ ë©”ì‹œì§€ (Toast) -->
        <div id="toast" class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-red-500 text-white px-6 py-2 rounded-full shadow-lg opacity-0 transition-opacity duration-300 pointer-events-none z-40">
            ì•Œë¦¼ ë©”ì‹œì§€
        </div>
    </div>

    <!-- ì˜¤ë¥¸ìª½: ì»¨íŠ¸ë¡¤ íŒ¨ë„ -->
    <div class="w-96 panel flex flex-col h-full shadow-2xl z-10">
        
        <!-- ìƒë‹¨ ì •ë³´ -->
        <div class="p-4 bg-gray-800 border-b border-gray-700">
            <h1 class="text-2xl font-bold text-yellow-500 mb-4 flex items-center gap-2">
                <span class="text-3xl">â™Ÿï¸</span> ì²´ìŠ¤ íƒ€ì›Œ ë””íœìŠ¤
            </h1>
            <div class="grid grid-cols-2 gap-4 text-sm">
                <div class="bg-gray-700 p-2 rounded flex justify-between">
                    <span class="text-gray-400">ì²´ë ¥ â¤ï¸</span>
                    <span id="livesDisplay" class="font-bold text-red-400">20</span>
                </div>
                <div class="bg-gray-700 p-2 rounded flex justify-between">
                    <span class="text-gray-400">ê³¨ë“œ ğŸª™</span>
                    <span id="moneyDisplay" class="font-bold text-yellow-400">150</span>
                </div>
                <div class="bg-gray-700 p-2 rounded flex justify-between">
                    <span class="text-gray-400">ì›¨ì´ë¸Œ ğŸŒŠ</span>
                    <span id="waveDisplay" class="font-bold text-blue-400">1</span>
                </div>
                <div class="bg-gray-700 p-2 rounded flex justify-between">
                    <span class="text-gray-400">ì  ìˆ˜ ğŸ‘¾</span>
                    <span id="enemyCountDisplay" class="font-bold text-purple-400">0</span>
                </div>
            </div>
            <button id="startWaveBtn" class="mt-4 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded shadow transition btn">
                ì›¨ì´ë¸Œ ì‹œì‘
            </button>
        </div>

        <!-- íƒ€ì›Œ ìƒì  -->
        <div class="flex-1 overflow-y-auto p-4">
            <h3 class="text-sm font-bold text-gray-500 uppercase tracking-wider mb-2">íƒ€ì›Œ ìƒì  (ë“œë˜ê·¸ ë¶ˆê°€: í´ë¦­ í›„ ë°°ì¹˜)</h3>
            <div class="grid grid-cols-2 gap-2" id="shopGrid">
                <!-- JSë¡œ ìƒì„±ë¨ -->
            </div>
        </div>

        <!-- ì„ íƒëœ íƒ€ì›Œ ì •ë³´ ë° ì—…ê·¸ë ˆì´ë“œ -->
        <div id="selectionPanel" class="p-4 bg-gray-800 border-t border-gray-700 hidden">
            <div class="flex justify-between items-start mb-2">
                <div>
                    <h3 id="selName" class="text-xl font-bold text-white">Pawn</h3>
                    <p id="selLevel" class="text-xs text-blue-400">Level 1</p>
                </div>
                <button id="sellBtn" class="text-xs text-red-400 hover:text-red-300 border border-red-900 bg-red-900/20 px-2 py-1 rounded">
                    íŒë§¤ ($<span id="sellPrice">0</span>)
                </button>
            </div>
            
            <div class="text-xs text-gray-400 mb-3 space-y-1">
                <p>ê³µê²©ë ¥: <span id="selDmg" class="text-white">10</span></p>
                <p>ì‚¬ê±°ë¦¬: <span id="selRange" class="text-white">100</span></p>
                <p>ì†ë„: <span id="selSpeed" class="text-white">1.0</span>/s</p>
                <p id="selSpecial" class="text-yellow-500 italic"></p>
            </div>

            <button id="upgradeBtn" class="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 rounded text-sm transition btn flex justify-between px-4">
                <span>ì—…ê·¸ë ˆì´ë“œ</span>
                <span>$<span id="upgradeCost">50</span></span>
            </button>
            
            <!-- í° í”„ë¡œëª¨ì…˜ ë©”ë‰´ (ìˆ¨ê¹€ ì²˜ë¦¬) -->
            <div id="promotionMenu" class="hidden mt-2 grid grid-cols-4 gap-1">
                <!-- JSë¡œ ë²„íŠ¼ ìƒì„± -->
            </div>
        </div>
    </div>

    <script>
        // --- ê²Œì„ ì„¤ì • ë° ìƒìˆ˜ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 40;
        const COLS = 20; // 800px
        const ROWS = 15; // 600px
        
        // íƒ€ì›Œ íƒ€ì… ì •ì˜
        const TOWER_TYPES = {
            PAWN: {
                id: 'PAWN', name: 'í°', symbol: 'â™Ÿ', color: '#a3d698', cost: 50, 
                range: 100, damage: 10, speed: 1000, maxLevel: 3,
                desc: 'ì§§ì€ ì‚¬ê±°ë¦¬. Lv3ì—ì„œ ë‹¤ë¥¸ ê¸°ë¬¼ë¡œ ë³€ì‹  ê°€ëŠ¥.'
            },
            ROOK: {
                id: 'ROOK', name: 'ë£©', symbol: 'â™œ', color: '#60a5fa', cost: 200, 
                range: 800, damage: 40, speed: 1200, maxLevel: 5,
                desc: 'ë§¤ìš° ê¸´ ì‚¬ê±°ë¦¬. ì‹­ì(+) ë°©í–¥ ì ë§Œ ê³µê²©.'
            },
            BISHOP: {
                id: 'BISHOP', name: 'ë¹„ìˆ', symbol: 'â™', color: '#c084fc', cost: 200, 
                range: 800, damage: 45, speed: 1200, maxLevel: 5,
                desc: 'ë§¤ìš° ê¸´ ì‚¬ê±°ë¦¬. ëŒ€ê°ì„ (X) ë°©í–¥ ì ë§Œ ê³µê²©.'
            },
            KNIGHT: {
                id: 'KNIGHT', name: 'ë‚˜ì´íŠ¸', symbol: 'â™', color: '#fb923c', cost: 250, 
                range: 120, damage: 20, speed: 400, maxLevel: 5,
                desc: 'ì§§ì€ ì‚¬ê±°ë¦¬, ë§¤ìš° ë¹ ë¥¸ ê³µê²©. í™•ë¥ ì  ê¸°ì ˆ.'
            },
            QUEEN: {
                id: 'QUEEN', name: 'í€¸', symbol: 'â™›', color: '#f87171', cost: 600, 
                range: 250, damage: 80, speed: 800, maxLevel: 5,
                desc: '8ë°©í–¥(ì‹­ì+ëŒ€ê°) ê³µê²©. ê°•ë ¥í•œ íŒŒê´´ë ¥.'
            },
            KING: {
                id: 'KING', name: 'í‚¹', symbol: 'â™š', color: '#fbbf24', cost: 400, 
                range: 150, damage: 5, speed: 2000, maxLevel: 3,
                desc: 'ì£¼ë³€ íƒ€ì›Œì˜ ê³µê²©ë ¥ê³¼ ì‚¬ê±°ë¦¬ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.'
            }
        };

        // --- ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
        let money = 250;
        let lives = 20;
        let wave = 1;
        let isWaveActive = false;
        let enemies = [];
        let towers = [];
        let projectiles = [];
        let particles = []; // íš¨ê³¼
        let path = [];
        let selectedTower = null;
        let placingTowerType = null;
        let lastTime = 0;
        let frameCount = 0;
        let waveEnemyCount = 0;
        let waveSpawnTimer = 0;
        
        // ë§µ ê²½ë¡œ (ê°„ë‹¨í•œ ì§€ê·¸ì¬ê·¸ ê²½ë¡œ ìƒì„±)
        function generatePath() {
            path = [];
            let r = 2, c = 0;
            path.push({c: 0, r: 2});
            while(c < COLS - 2) { c++; path.push({c, r}); }
            while(r < 6) { r++; path.push({c, r}); }
            while(c > 2) { c--; path.push({c, r}); }
            while(r < 10) { r++; path.push({c, r}); }
            while(c < COLS - 1) { c++; path.push({c, r}); }
            path.push({c: COLS-1, r: 10}); // End
        }
        generatePath();

        // --- í´ë˜ìŠ¤ ì •ì˜ ---

        class Enemy {
            constructor(wave) {
                this.pathIndex = 0;
                // ê²½ë¡œì˜ ì‹œì‘ì ì„ ì•½ê°„ ë²—ì–´ë‚˜ì„œ ë¶€ë“œëŸ½ê²Œ ì§„ì…í•˜ë„ë¡
                this.x = path[0].c * GRID_SIZE + GRID_SIZE/2;
                this.y = path[0].r * GRID_SIZE + GRID_SIZE/2;
                this.targetIndex = 1;
                
                // ì›¨ì´ë¸Œ ë‚œì´ë„ ì¡°ì ˆ
                this.hp = 20 + (wave * wave * 5);
                this.maxHp = this.hp;
                this.speed = 100 + (wave * 5); // í”½ì…€/ì´ˆ
                this.radius = 12;
                this.color = `hsl(${wave * 20}, 70%, 50%)`;
                this.stunned = 0; // ê¸°ì ˆ ì‹œê°„
            }

            update(dt) {
                if (this.stunned > 0) {
                    this.stunned -= dt;
                    return;
                }

                if (this.targetIndex >= path.length) return; // ë ë„ë‹¬

                const target = path[this.targetIndex];
                const tx = target.c * GRID_SIZE + GRID_SIZE/2;
                const ty = target.r * GRID_SIZE + GRID_SIZE/2;

                const dx = tx - this.x;
                const dy = ty - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 5) {
                    this.pathIndex++;
                    this.targetIndex++;
                    if (this.targetIndex >= path.length) {
                        this.reachedEnd();
                    }
                } else {
                    const moveDist = (this.speed * dt) / 1000;
                    this.x += (dx / dist) * moveDist;
                    this.y += (dy / dist) * moveDist;
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // ì²´ë ¥ë°”
                const hpPct = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - 10, this.y - 20, 20, 4);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(this.x - 10, this.y - 20, 20 * hpPct, 4);

                if (this.stunned > 0) {
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.font = '10px Arial';
                    ctx.fillStyle = 'yellow';
                    ctx.fillText('âš¡', this.x-4, this.y-4);
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    money += 5 + Math.floor(wave/2);
                    updateUI();
                    createParticles(this.x, this.y, this.color);
                    return true; // ì£½ìŒ
                }
                return false; // ìƒì¡´
            }

            reachedEnd() {
                lives--;
                this.hp = 0; // ì œê±° íŠ¸ë¦¬ê±°
                updateUI();
                showToast(`ì  í†µê³¼! ì²´ë ¥ ê°ì†Œ (${lives})`);
                if (lives <= 0) gameOver();
            }
        }

        class Tower {
            constructor(c, r, typeKey) {
                this.c = c;
                this.r = r;
                this.x = c * GRID_SIZE + GRID_SIZE/2;
                this.y = r * GRID_SIZE + GRID_SIZE/2;
                this.typeKey = typeKey;
                this.level = 1;
                this.cooldown = 0;
                this.buffs = { damage: 1, range: 1, speed: 1 }; // í‚¹ ë²„í”„ìš©
                this.applyTypeStats(typeKey);
            }

            applyTypeStats(key) {
                const type = TOWER_TYPES[key];
                this.name = type.name;
                this.symbol = type.symbol;
                this.color = type.color;
                this.baseRange = type.range;
                this.baseDamage = type.damage;
                this.baseSpeed = type.speed; // ms delay
                this.maxLevel = type.maxLevel;
            }

            get damage() { return this.baseDamage * (1 + (this.level-1)*0.5) * this.buffs.damage; }
            get range() { return this.baseRange * (1 + (this.level-1)*0.2) * this.buffs.range; }
            get speed() { return Math.max(100, this.baseSpeed * Math.pow(0.9, this.level-1) / this.buffs.speed); }

            update(dt, enemies) {
                if (this.cooldown > 0) this.cooldown -= dt;

                // ë²„í”„ ì´ˆê¸°í™” (ë§¤ í”„ë ˆì„ ì¬ê³„ì‚°, í‚¹ ë¡œì§ì—ì„œ ì„¤ì •ë¨)
                this.buffs = { damage: 1, range: 1, speed: 1 };

                if (this.typeKey === 'KING') {
                    // í‚¹ì€ ê³µê²©ë³´ë‹¤ëŠ” ë²„í”„ ë¶€ì—¬ (ê·¸ëŸ¬ë‚˜ ì‚¬ê±°ë¦¬ ë‚´ ì  ê³µê²©ë„ í•¨)
                    // ì£¼ë³€ 8ì¹¸ íƒ€ì›Œ ë²„í”„ ë¡œì§ì€ Game Loopì—ì„œ ë³„ë„ ì²˜ë¦¬
                }
            }

            tryAttack(enemies) {
                if (this.cooldown > 0) return;

                let target = null;

                // íŠ¹ìˆ˜ ê³µê²© ë¡œì§
                if (this.typeKey === 'ROOK') {
                    target = this.findTargetInLines(enemies, false); // ì‹­ì
                } else if (this.typeKey === 'BISHOP') {
                    target = this.findTargetInLines(enemies, true); // ëŒ€ê°ì„ 
                } else if (this.typeKey === 'QUEEN') {
                    // ì‹­ì + ëŒ€ê°ì„  ëª¨ë‘ ì²´í¬
                    target = this.findTargetInLines(enemies, false) || this.findTargetInLines(enemies, true);
                } else {
                    // ì¼ë°˜ ê±°ë¦¬ ê¸°ë°˜ (í°, ë‚˜ì´íŠ¸, í‚¹)
                    target = this.findTargetByDistance(enemies);
                }

                if (target) {
                    this.fire(target);
                    this.cooldown = this.speed;
                }
            }

            findTargetByDistance(enemies) {
                let nearest = null;
                let minDist = Infinity;
                for (const e of enemies) {
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if (dist <= this.range && dist < minDist) {
                        minDist = dist;
                        nearest = e;
                    }
                }
                return nearest;
            }

            findTargetInLines(enemies, diagonal) {
                // ê´‘ì„  ê³µê²© íŒì • (ë‘ê»˜ í—ˆìš© ë²”ìœ„)
                const BEAM_WIDTH = 20; 
                let bestTarget = null;
                let maxProgress = -1; // ê°€ì¥ ì•ì— ìˆëŠ” ì  ìš°ì„ 

                for (const e of enemies) {
                    const dx = e.x - this.x;
                    const dy = e.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > this.range) continue;

                    let hit = false;
                    if (!diagonal) {
                        // ì‹­ì: xê°€ ë¹„ìŠ·í•˜ê±°ë‚˜ yê°€ ë¹„ìŠ·í•¨
                        if (Math.abs(dx) < BEAM_WIDTH || Math.abs(dy) < BEAM_WIDTH) hit = true;
                    } else {
                        // ëŒ€ê°ì„ : |dx| ì™€ |dy| ê°€ ë¹„ìŠ·í•¨
                        if (Math.abs(Math.abs(dx) - Math.abs(dy)) < BEAM_WIDTH) hit = true;
                    }

                    if (hit && e.pathIndex > maxProgress) {
                        maxProgress = e.pathIndex;
                        bestTarget = e;
                    }
                }
                return bestTarget;
            }

            fire(target) {
                projectiles.push(new Projectile(this.x, this.y, target, this));
            }

            upgrade() {
                if (this.level < this.maxLevel) {
                    this.level++;
                    createParticles(this.x, this.y, '#fff', 10);
                }
            }
        }

        class Projectile {
            constructor(x, y, target, tower) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.tower = tower;
                this.damage = tower.damage;
                this.speed = 400; // ë°œì‚¬ì²´ ì†ë„
                this.active = true;
                
                // ìœ ë„íƒ„ ì•„ë‹˜ (ì²´ìŠ¤ íŠ¹ì„± ì‚´ë¦¬ê¸° ìœ„í•´)
                // íƒ€ê²Ÿì˜ í˜„ì¬ ìœ„ì¹˜ë¥¼ í–¥í•´ ë°œì‚¬
                const angle = Math.atan2(target.y - y, target.x - x);
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;

                // íŠ¹ìˆ˜ íš¨ê³¼
                this.isStun = (tower.typeKey === 'KNIGHT' && Math.random() < 0.3);
            }

            update(dt) {
                this.x += (this.vx * dt) / 1000;
                this.y += (this.vy * dt) / 1000;

                // í™”ë©´ ë°– ì²´í¬
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.active = false;
                }

                // ì¶©ëŒ ì²´í¬ (ë‹¨ìˆœ ì›í˜•)
                for (const e of enemies) {
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if (dist < e.radius + 5) {
                        this.hit(e);
                        this.active = false;
                        break;
                    }
                }
            }

            hit(enemy) {
                enemy.takeDamage(this.damage);
                if (this.isStun) enemy.stunned = 1000; // 1ì´ˆ ê¸°ì ˆ
            }

            draw(ctx) {
                ctx.fillStyle = this.tower.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // --- ë©”ì¸ ë¡œì§ ---

        function init() {
            // ìƒì  UI ìƒì„±
            const shopGrid = document.getElementById('shopGrid');
            for (const key in TOWER_TYPES) {
                if (key === 'PAWN_PROMO') continue; // ë‚´ë¶€ìš© ì œì™¸

                const t = TOWER_TYPES[key];
                const btn = document.createElement('div');
                btn.className = `tower-card bg-gray-700 p-2 rounded cursor-pointer border border-gray-600 flex flex-col items-center`;
                btn.innerHTML = `
                    <div class="text-3xl mb-1" style="color:${t.color}">${t.symbol}</div>
                    <div class="font-bold text-sm text-white">${t.name}</div>
                    <div class="text-xs text-yellow-400">$${t.cost}</div>
                `;
                btn.onclick = () => selectShopItem(key, btn);
                shopGrid.appendChild(btn);
            }

            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            canvas.addEventListener('mousedown', handleCanvasClick);
            document.getElementById('startWaveBtn').addEventListener('click', startWave);
            document.getElementById('upgradeBtn').addEventListener('click', upgradeSelectedTower);
            document.getElementById('sellBtn').addEventListener('click', sellSelectedTower);

            requestAnimationFrame(gameLoop);
            updateUI();
        }

        function selectShopItem(key, element) {
            document.querySelectorAll('.tower-card').forEach(el => el.classList.remove('selected'));
            
            // í† ê¸€ ë¡œì§
            if (placingTowerType === key) {
                placingTowerType = null; // ì·¨ì†Œ
                selectedTower = null;
                updateSelectionPanel();
            } else {
                element.classList.add('selected');
                placingTowerType = key;
                selectedTower = null; // ìƒì  ì„ íƒ ì‹œ ê¸°ì¡´ íƒ€ì›Œ ì„ íƒ í•´ì œ
                showToast(`${TOWER_TYPES[key].name} ì„ íƒë¨: ë°°ì¹˜í•  ìœ„ì¹˜ í´ë¦­`);
                updateSelectionPanel();
            }
        }

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const c = Math.floor(mouseX / GRID_SIZE);
            const r = Math.floor(mouseY / GRID_SIZE);

            // ë²”ìœ„ ë°–
            if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return;

            // ì´ë¯¸ íƒ€ì›Œê°€ ìˆëŠ”ê°€?
            const existingTower = towers.find(t => t.c === c && t.r === r);

            if (placingTowerType) {
                // íƒ€ì›Œ ë°°ì¹˜ ì‹œë„
                if (existingTower) {
                    showToast("ì´ë¯¸ íƒ€ì›Œê°€ ìˆìŠµë‹ˆë‹¤.");
                    return;
                }
                
                // ê²½ë¡œ ìœ„ì¸ê°€?
                const onPath = path.some(p => p.c === c && p.r === r);
                if (onPath) {
                    showToast("ê²½ë¡œ ìœ„ì—ëŠ” ê±´ì„¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    return;
                }

                const cost = TOWER_TYPES[placingTowerType].cost;
                if (money >= cost) {
                    money -= cost;
                    towers.push(new Tower(c, r, placingTowerType));
                    placingTowerType = null; // ë°°ì¹˜ í›„ ì„ íƒ í•´ì œ
                    document.querySelectorAll('.tower-card').forEach(el => el.classList.remove('selected'));
                    createParticles(c * GRID_SIZE + GRID_SIZE/2, r * GRID_SIZE + GRID_SIZE/2, '#fff', 20);
                    updateUI();
                } else {
                    showToast("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!");
                }
            } else {
                // íƒ€ì›Œ ì„ íƒ
                if (existingTower) {
                    selectedTower = existingTower;
                    updateSelectionPanel();
                } else {
                    selectedTower = null;
                    document.getElementById('selectionPanel').classList.add('hidden');
                }
            }
        }

        function upgradeSelectedTower() {
            if (!selectedTower) return;
            
            // í° í”„ë¡œëª¨ì…˜ ì²´í¬
            if (selectedTower.typeKey === 'PAWN' && selectedTower.level === 3) {
                // í”„ë¡œëª¨ì…˜ì€ ë³„ë„ UIì—ì„œ ì²˜ë¦¬ (ì´ë¯¸ ì—´ë ¤ìˆìŒ)
                return;
            }

            const cost = Math.floor(TOWER_TYPES[selectedTower.typeKey].cost * selectedTower.level * 0.8);
            if (money >= cost) {
                if (selectedTower.level < selectedTower.maxLevel) {
                    money -= cost;
                    selectedTower.upgrade();
                    updateSelectionPanel();
                    updateUI();
                    showToast("ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ!");
                } else {
                    showToast("ì´ë¯¸ ìµœëŒ€ ë ˆë²¨ì…ë‹ˆë‹¤.");
                }
            } else {
                showToast("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
            }
        }
        
        function promotePawn(newTypeKey) {
            if (!selectedTower || selectedTower.typeKey !== 'PAWN') return;
            
            const cost = 300; // í”„ë¡œëª¨ì…˜ ë¹„ìš©
            if (money >= cost) {
                money -= cost;
                // íƒ€ì›Œ ì†ì„± ë³€ê²½
                selectedTower.typeKey = newTypeKey;
                selectedTower.level = 1; // ë³€ì‹  í›„ 1ë ˆë²¨ë¶€í„°
                selectedTower.applyTypeStats(newTypeKey);
                
                createParticles(selectedTower.x, selectedTower.y, 'gold', 30);
                showToast(`í”„ë¡œëª¨ì…˜: ${TOWER_TYPES[newTypeKey].name}!`);
                updateSelectionPanel();
                updateUI();
            } else {
                showToast("í”„ë¡œëª¨ì…˜ ë¹„ìš©($300)ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
            }
        }

        function sellSelectedTower() {
            if (!selectedTower) return;
            const refund = Math.floor(TOWER_TYPES[selectedTower.typeKey].cost * 0.5 * selectedTower.level);
            money += refund;
            towers = towers.filter(t => t !== selectedTower);
            selectedTower = null;
            document.getElementById('selectionPanel').classList.add('hidden');
            updateUI();
            createParticles(selectedTower.x, selectedTower.y, 'gray', 10); // ì‚­ì œ ì „ ìœ„ì¹˜ì— íš¨ê³¼
        }

        function startWave() {
            if (isWaveActive) return;
            isWaveActive = true;
            waveEnemyCount = 5 + wave * 2;
            waveSpawnTimer = 0;
            document.getElementById('startWaveBtn').disabled = true;
            document.getElementById('startWaveBtn').innerText = "ì›¨ì´ë¸Œ ì§„í–‰ ì¤‘...";
            showToast(`ì›¨ì´ë¸Œ ${wave} ì‹œì‘!`);
        }

        function gameLoop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;

            // 1. ì—…ë°ì´íŠ¸
            // í‚¹ ë²„í”„ ì ìš©
            towers.forEach(t => {
                if (t.typeKey === 'KING') {
                    // ì£¼ë³€ 1ì¹¸ ë²”ìœ„ (3x3)
                    for (const other of towers) {
                        if (t === other) continue;
                        if (Math.abs(t.c - other.c) <= 1 && Math.abs(t.r - other.r) <= 1) {
                            other.buffs.damage += 0.2 + (t.level * 0.1);
                            other.buffs.range += 0.2;
                            other.buffs.speed += 0.2;
                        }
                    }
                }
            });

            // ì  ìŠ¤í°
            if (isWaveActive && waveEnemyCount > 0) {
                waveSpawnTimer -= dt;
                if (waveSpawnTimer <= 0) {
                    enemies.push(new Enemy(wave));
                    waveEnemyCount--;
                    waveSpawnTimer = 1000 - Math.min(800, wave * 50); // ì›¨ì´ë¸Œê°€ ê°ˆìˆ˜ë¡ ë¹¨ë¦¬ ë‚˜ì˜´
                }
            } else if (isWaveActive && waveEnemyCount === 0 && enemies.length === 0) {
                // ì›¨ì´ë¸Œ ì¢…ë£Œ
                isWaveActive = false;
                wave++;
                money += 100 + wave * 10;
                document.getElementById('startWaveBtn').disabled = false;
                document.getElementById('startWaveBtn').innerText = "ë‹¤ìŒ ì›¨ì´ë¸Œ ì‹œì‘";
                updateUI();
                showToast("ì›¨ì´ë¸Œ í´ë¦¬ì–´!");
            }

            // íƒ€ì›Œ ê³µê²© ì‹œë„
            towers.forEach(t => {
                t.update(dt, enemies);
                t.tryAttack(enemies);
            });

            // ë°œì‚¬ì²´ ì´ë™
            projectiles.forEach(p => p.update(dt));
            projectiles = projectiles.filter(p => p.active);

            // ì  ì´ë™
            enemies.forEach(e => e.update(dt));
            enemies = enemies.filter(e => e.hp > 0);

            // íŒŒí‹°í´
            particles.forEach(p => {
                p.life -= dt;
                p.x += p.vx;
                p.y += p.vy;
            });
            particles = particles.filter(p => p.life > 0);


            // 2. ê·¸ë¦¬ê¸°
            // ë°°ê²½ ì§€ìš°ê¸°
            ctx.fillStyle = '#2d2d2d';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸° (ì²´ìŠ¤íŒ ëŠë‚Œ)
            for (let r=0; r<ROWS; r++) {
                for (let c=0; c<COLS; c++) {
                    if ((r+c)%2 === 0) {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(c*GRID_SIZE, r*GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
            }

            // ê²½ë¡œ ê·¸ë¦¬ê¸°
            ctx.strokeStyle = '#444';
            ctx.lineWidth = GRID_SIZE * 0.6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            if (path.length > 0) {
                ctx.moveTo(path[0].c * GRID_SIZE + GRID_SIZE/2, path[0].r * GRID_SIZE + GRID_SIZE/2);
                for (let i=1; i<path.length; i++) {
                    ctx.lineTo(path[i].c * GRID_SIZE + GRID_SIZE/2, path[i].r * GRID_SIZE + GRID_SIZE/2);
                }
            }
            ctx.stroke();

            // ë²”ìœ„ í‘œì‹œ (ì„ íƒ ë˜ëŠ” ë°°ì¹˜ ì¤‘ì¼ ë•Œ)
            if (placingTowerType) {
                // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ (ê°„ë‹¨íˆ êµ¬í˜„í•˜ê¸° ìœ„í•´ ìƒëµí•˜ê±°ë‚˜ í•„ìš”ì‹œ ì¶”ê°€)
            }
            if (selectedTower) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.arc(selectedTower.x, selectedTower.y, selectedTower.range, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fill();
                ctx.stroke();

                // íŠ¹ìˆ˜ ë²”ìœ„ ì‹œê°í™”
                if (selectedTower.typeKey === 'ROOK' || selectedTower.typeKey === 'QUEEN') {
                    ctx.fillStyle = 'rgba(96, 165, 250, 0.2)';
                    ctx.fillRect(0, selectedTower.y - 10, canvas.width, 20);
                    ctx.fillRect(selectedTower.x - 10, 0, 20, canvas.height);
                }
                if (selectedTower.typeKey === 'BISHOP' || selectedTower.typeKey === 'QUEEN') {
                    // ëŒ€ê°ì„  ì‹œê°í™”ëŠ” ë³µì¡í•˜ë¯€ë¡œ ìƒëµí•˜ê±°ë‚˜ ê°„ë‹¨íˆ ì„ ìœ¼ë¡œ í‘œí˜„
                    ctx.strokeStyle = 'rgba(192, 132, 252, 0.3)';
                    ctx.lineWidth = 20;
                    ctx.beginPath();
                    // ëŒ€ê°ì„  1
                    ctx.moveTo(selectedTower.x - 1000, selectedTower.y - 1000);
                    ctx.lineTo(selectedTower.x + 1000, selectedTower.y + 1000);
                    // ëŒ€ê°ì„  2
                    ctx.moveTo(selectedTower.x + 1000, selectedTower.y - 1000);
                    ctx.lineTo(selectedTower.x - 1000, selectedTower.y + 1000);
                    ctx.stroke();
                }
            }

            // ì  ê·¸ë¦¬ê¸°
            enemies.forEach(e => e.draw(ctx));

            // íƒ€ì›Œ ê·¸ë¦¬ê¸°
            towers.forEach(t => {
                // íƒ€ì›Œ ë³¸ì²´
                ctx.fillStyle = '#222';
                ctx.fillRect(t.c*GRID_SIZE+4, t.r*GRID_SIZE+4, GRID_SIZE-8, GRID_SIZE-8);
                
                // ì„ íƒ í‘œì‹œ
                if (t === selectedTower) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(t.c*GRID_SIZE+2, t.r*GRID_SIZE+2, GRID_SIZE-4, GRID_SIZE-4);
                }

                // ì‹¬ë³¼
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = t.color;
                ctx.fillText(t.symbol, t.x, t.y + 2);

                // ë ˆë²¨ í‘œì‹œ (ì )
                ctx.fillStyle = 'gold';
                for(let i=0; i<t.level; i++) {
                    ctx.fillRect(t.x - (t.level*3) + (i*6) + 1, t.y - 18, 4, 4);
                }
            });

            // ë°œì‚¬ì²´ ê·¸ë¦¬ê¸°
            projectiles.forEach(p => p.draw(ctx));

            // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 500;
                ctx.fillRect(p.x, p.y, 3, 3);
                ctx.globalAlpha = 1;
            });

            requestAnimationFrame(gameLoop);
        }

        // --- ìœ í‹¸ë¦¬í‹° ë° UI ---

        function updateUI() {
            document.getElementById('moneyDisplay').innerText = money;
            document.getElementById('livesDisplay').innerText = lives;
            document.getElementById('waveDisplay').innerText = wave;
            document.getElementById('enemyCountDisplay').innerText = enemies.length + waveEnemyCount;
        }

        function updateSelectionPanel() {
            const panel = document.getElementById('selectionPanel');
            const promoMenu = document.getElementById('promotionMenu');
            promoMenu.innerHTML = ''; // ì´ˆê¸°í™”

            if (!selectedTower) {
                panel.classList.add('hidden');
                return;
            }
            panel.classList.remove('hidden');

            const type = TOWER_TYPES[selectedTower.typeKey];
            document.getElementById('selName').innerText = type.name;
            document.getElementById('selLevel').innerText = `Lv ${selectedTower.level} / ${selectedTower.maxLevel}`;
            document.getElementById('selDmg').innerText = Math.floor(selectedTower.damage);
            document.getElementById('selRange').innerText = Math.floor(selectedTower.range);
            document.getElementById('selSpeed').innerText = (selectedTower.speed/1000).toFixed(2);
            document.getElementById('selSpecial').innerText = type.desc;
            
            // íŒë§¤ ê°€ê²©
            const sellPrice = Math.floor(type.cost * 0.5 * selectedTower.level);
            document.getElementById('sellBtn').innerHTML = `íŒë§¤ ($${sellPrice})`;

            // ì—…ê·¸ë ˆì´ë“œ ë²„íŠ¼ ìƒíƒœ
            const btn = document.getElementById('upgradeBtn');
            const costSpan = document.getElementById('upgradeCost');
            
            // í° í”„ë¡œëª¨ì…˜ ë¡œì§
            if (selectedTower.typeKey === 'PAWN' && selectedTower.level === 3) {
                btn.classList.add('hidden');
                promoMenu.classList.remove('hidden');
                
                // í”„ë¡œëª¨ì…˜ ë²„íŠ¼ ìƒì„±
                ['KNIGHT', 'BISHOP', 'ROOK', 'QUEEN'].forEach(pKey => {
                    const pType = TOWER_TYPES[pKey];
                    const pBtn = document.createElement('button');
                    pBtn.className = "bg-gray-700 hover:bg-gray-600 text-white p-2 rounded text-xs flex flex-col items-center border border-gray-500";
                    pBtn.innerHTML = `<span style="color:${pType.color}" class="text-lg">${pType.symbol}</span><span>$300</span>`;
                    pBtn.onclick = () => promotePawn(pKey);
                    promoMenu.appendChild(pBtn);
                });

            } else {
                btn.classList.remove('hidden');
                promoMenu.classList.add('hidden');
                
                if (selectedTower.level >= selectedTower.maxLevel) {
                    btn.disabled = true;
                    btn.classList.add('bg-gray-600');
                    btn.classList.remove('bg-blue-600');
                    costSpan.innerText = "-";
                    btn.querySelector('span:first-child').innerText = "ìµœëŒ€ ë ˆë²¨";
                } else {
                    const upCost = Math.floor(type.cost * selectedTower.level * 0.8);
                    btn.disabled = money < upCost;
                    btn.classList.toggle('bg-gray-600', money < upCost);
                    btn.classList.toggle('bg-blue-600', money >= upCost);
                    costSpan.innerText = upCost;
                    btn.querySelector('span:first-child').innerText = "ì—…ê·¸ë ˆì´ë“œ";
                }
            }
        }

        function createParticles(x, y, color, count = 5) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 500,
                    color: color
                });
            }
        }

        function showToast(msg) {
            const el = document.getElementById('toast');
            el.innerText = msg;
            el.style.opacity = '1';
            el.style.top = '20px';
            setTimeout(() => {
                el.style.opacity = '0';
                el.style.top = '10px';
            }, 2000);
        }

        function gameOver() {
            isWaveActive = false;
            document.getElementById('modalTitle').innerText = "GAME OVER";
            document.getElementById('modalTitle').classList.add('text-red-500');
            document.getElementById('modalMessage').innerText = `ë‹¹ì‹ ì€ ì›¨ì´ë¸Œ ${wave}ê¹Œì§€ ë²„í…¼ìŠµë‹ˆë‹¤.`;
            document.getElementById('modalOverlay').classList.remove('hidden');
        }

        // ì‹¤í–‰
        window.onload = init;

    </script>
</body>
</html>
